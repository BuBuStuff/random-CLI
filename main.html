<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BuBuCLI</title>
    <style>
        body {
            font-family: "Courier New", Courier, monospace;
            background-color: #1e1e1e;
            color: #00ff00;
            margin: 0;
            padding: 0;
        }
        #terminal {
            padding: 10px;
            height: 100vh;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        #inputLine {
            display: flex;
        }
        #inputLine span {
            margin-right: 5px;
        }
        input {
            background: transparent;
            color: #00ff00;
            border: none;
            outline: none;
            font-size: 16px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="terminal">
    </div>
    <div id="inputLine">
        <span>&gt;</span>
        <input type="text" id="userInput" autofocus onkeydown="handleInput(event)" />
    </div>

    <script>
        const terminal = document.getElementById("terminal");
        const userInput = document.getElementById("userInput");

        function handleInput(event) {
            if (event.key === 'Enter') {
                const command = userInput.value.trim();
                if (command) {
                    executeCommand(command);
                }
                userInput.value = '';
            }
        }

		function retrieveLongTextInput(command, position) {
			let partsText = command.split(/\s+/);
			let resultText = partsText.slice(position).join(' ');
		}
		
        function executeCommand(command) {
            const commandOutput = document.createElement('div');
            commandOutput.textContent = `$ ${command}`;
            terminal.appendChild(commandOutput);
            const output = document.createElement('div');
			output.textContent = "BuBu CLI - General CmdSet";
            if (command === 'clear') {
                terminal.innerHTML = '';
            } else if (command === 'help') {
				var helpOutput = "gs <time24H>: gets the number of seconds till time given from now.\ndataurl / $" + " % <htmlCode>";
                output.textContent = helpOutput;
            } else if (command.includes('dataurl')) {
				var ncode = command.split(' / $' + ' % ');
				// terminal.innerHTML = '';
				var b64code = `data:text/html;base64,` + atob(ncode);
				output.textContent = b64code;
			} else if (command.includes('gs')) {
				function convertToTime(dateString) {
  					let hours = parseInt(dateString.slice(0, 2), 10);
  					let minutes = parseInt(dateString.slice(2), 10);
					let currentDate = new Date();
					currentDate.setHours(hours);
					currentDate.setMinutes(minutes);
					currentDate.setSeconds(0);
					currentDate.setMilliseconds(0);
					return currentDate;
				}
				function getTimeDifferenceInSeconds(targetTimeString) {
  					let targetTime = convertToTime(targetTimeString);
					let now = new Date();
					if (targetTime < now) {
    					targetTime.setDate(targetTime.getDate() + 1);
					}
					let timeDifferenceInMilliseconds = targetTime - now;
					let timeDifferenceInSeconds = Math.floor(timeDifferenceInMilliseconds / 1000);
					return timeDifferenceInSeconds;
				}
				let targetTimeString = command.split(' ')[1];
				let secondsUntilTarget = getTimeDifferenceInSeconds(targetTimeString);
				output.textContent = `Time until ${targetTimeString}: ${secondsUntilTarget}`;



				
            } else if (command.includes('cipher')) {



				
				var msg1 = command.split(' ')[2];
				class SuperSecretCipher {
  					constructor(key) {
    				this.key = key;
  				}
 encrypt(message) {
    let encryptedMessage = '';
    let keyIndex = 0;
    for (let i = 0; i < message.length; i++) {
      let messageChar = message.charCodeAt(i);
      let keyChar = this.key.charCodeAt(keyIndex % this.key.length);
      // Encrypt by shifting the char code based on the key
      encryptedMessage += String.fromCharCode(messageChar + keyChar);
      keyIndex++;
    }
    return encryptedMessage;
  }

  // Function to decrypt a message using the same key
  decrypt(encryptedMessage) {
    let decryptedMessage = '';
    let keyIndex = 0;
    for (let i = 0; i < encryptedMessage.length; i++) {
      let encryptedChar = encryptedMessage.charCodeAt(i);
      let keyChar = this.key.charCodeAt(keyIndex % this.key.length);
      // Decrypt by reversing the shift
      decryptedMessage += String.fromCharCode(encryptedChar - keyChar);
      keyIndex++;
    }
    return decryptedMessage;
  }
}
				const secretKey = command.split(' ')[3];
const cipher = new SuperSecretCipher(secretKey);

				if (command.split(' ')[1] === "decrypt") {
					var outputMsg1 = cipher.decrypt(command.split(' ')[2]);
				} else if (command.split(' ')[1] === "encrypt") {
					var outputMsg1 = cipher.encrypt(command.split(' ')[2]);
				}

				output.textContent = `${outputMsg1}`;
				// cipher encrypt message key


				
			} else if (command.includes('crypt')) {




if (!command === 'crypt generate') {
				

				const crypto = require('crypto');

// Encryption function
function encrypt(text, key) {
    const iv = crypto.randomBytes(16); // Initialization vector
    const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(key, 'utf-8'), iv);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return iv.toString('hex') + ':' + encrypted; // Return iv with encrypted data
}

// Decryption function
function decrypt(encryptedText, key) {
    const textParts = encryptedText.split(':');
    const iv = Buffer.from(textParts.shift(), 'hex');
    const encryptedData = textParts.join(':');
    const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(key, 'utf-8'), iv);
    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
}

// Example usage
const key = command.split(' ')[2]; // key is 32 bytes long (256 bits) for AES-256
let partsText = command.split(/\s+/);
let resultText = partsText.slice(3).join(' ');
const text = resultText;
alert(text);

if (command.split(' ')[1] === "encrypt") {				
const encrypted = encrypt(text, key);
output.textContent = encrypted;
}
if (command.split(' ')[1] === "decrypt") {				
const decrypted = decrypt(text, key);
output.textContent = decrypted;
}
				
} else {
function generateUniqueKey(length = 32) {
    const array = new Uint8Array(length);
    window.crypto.getRandomValues(array);
    return Array.from(array).map(byte => byte.toString(16).padStart(2, '0')).join('');
}

const uniqueKey = generateUniqueKey();
output.textContent = uniqueKey;
	
}     
	//output.textContent = "Available commands: help, clear";

// crypt <encrypt/decrypt> <key> <message>





































				

				
            } else if (command.includes('cryp')) {
// Define a secret key
const secretKey = command.split(' ')[2]; // Use a 16-character key for AES-128 "DG1l4qh7A9yFBIFk"
const methodFunc = command.split(' ')[1];
// Function to encrypt a message
function toHex(array) {
    return Array.from(array).map(byte => byte.toString(16).padStart(2, '0')).join('');
}

// Helper function to convert a hexadecimal string back to a Uint8Array
function fromHex(hexString) {
    const byteArray = [];
    for (let i = 0; i < hexString.length; i += 2) {
        byteArray.push(parseInt(hexString.substr(i, 2), 16));
    }
    return new Uint8Array(byteArray);
}

async function encrypt(message, key) {
    const encoder = new TextEncoder();
    const data = encoder.encode(message);

    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        encoder.encode(key),
        { name: 'AES-CBC' },
        false,
        ['encrypt']
    );

    const iv = crypto.getRandomValues(new Uint8Array(16)); // Generate a random IV
    const encryptedData = await crypto.subtle.encrypt(
        { name: 'AES-CBC', iv },
        cryptoKey,
        data
    );

    // Combine IV and ciphertext as hex strings separated by a colon
    let returnEncoded = `${toHex(iv)}` + `:` + `${toHex(new Uint8Array(encryptedData))}`.toString();
	output.textContent = returnEncoded;
	return returnEncoded;
}

async function decrypt(encryptedText, key) {
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();

    const cryptoKey = await crypto.subtle.importKey(
        'raw',
        encoder.encode(key),
        { name: 'AES-CBC' },
        false,
        ['decrypt']
    );

    // Split the encrypted text into IV and ciphertext
    const [ivHex, ciphertextHex] = encryptedText.split(':');
    const iv = fromHex(ivHex);
    const ciphertext = fromHex(ciphertextHex);

    const decryptedData = await crypto.subtle.decrypt(
        { name: 'AES-CBC', iv },
        cryptoKey,
        ciphertext
    );

    return decoder.decode(decryptedData);
}

// Example usage
(async function () {
    const message = retrieveLongTextInput(command, 3);

	if (methodFunc === "encrypt") {
	const encrypted = await encrypt(message, secretKey);
    //output.textContent = encrypted;
} else if (methodFunc === "decrypt") {
    // Decrypt the message
    const decrypted = await decrypt(encrypted, secretKey);
    output.textContent = decrypted;
} else if (methodFunc === "generate") {
		
} else {
		output.textContent = "Invalid value - field 2";
}
})();
            } else if (command === 'cmd5') {
// Function to generate a random secret key
function generateSecretKey(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let secretKey = '';
    for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * characters.length);
        secretKey += characters[randomIndex];
    }
    return secretKey;
}

// Example usage
const keyLength = 16; // Length of the secret key (e.g., 16 for AES-128, 32 for AES-256)
const secretKey = generateSecretKey(keyLength);
output.textContent = 'Generated Secret Key:' + secretKey;
            } else if (command === 'cmd6') {
                output.textContent = "Available commands: help, clear";
            } else if (command === 'cmd7') {
                output.textContent = "Available commands: help, clear";
            } else if (command === 'cmd8') {
                output.textContent = "Available commands: help, clear";
            } else if (command === 'cmd9') {
                output.textContent = "Available commands: help, clear";
            } else if (command === 'cmd0') {
                output.textContent = "Available commands: help, clear";
            } else {
                output.textContent = `Command not recognized: ${command}`;
            }

            terminal.appendChild(output);
            terminal.scrollTop = terminal.scrollHeight;
        }
    </script>
</body>
</html>
